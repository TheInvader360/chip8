;****************************************************************************
;
;                      A minehunter in  Super CHIP-8
;                    (C)Copyright 1997 by David WINTER
;
;
;       This source is to show to the novice programer how we can
;       programm some nice games (i.e: not PONG and clones (just
;       teasing the nostalgics...)) in CHIP-8 and Super CHIP-8.
;
;       I decided to diffuse this source in the hope that some
;       people will write new games for the SCHIP/CHIP-8 emulators.
;
;       This game, as well as the others for this scene, are FREE
;       and freely ditributable. If you paid to have it, you have
;       been stolen. If you got money to give it, you're a thief.
;
;
;
;       The rules of this game are very simple: the game is played
;       on a 18*9 squares playing field. On this playing field, some
;       squares are MINED, some others are not. The goal is to find
;       all the non mined ones. To do so, you just move around a
;       cursor, and check the squares you want. If the square you're
;       checking is mined, you lost, and all the mines are shown.
;       If not, the game puts a number on the square, which
;       tells how many mines are placed around it (if there are no mines
;       around, the square is blanked). It is to you to make the logic
;       deductions to find the non mined squares. To help you, the game
;       allows putting marks on the squares which are believed to be
;       mined.
;
;       The keys are:
;                   [8] :   UP
;                   [4] :   LEFT (lower level under level selection)
;                   [5] :   SHOW SQUARE (start game under level selection)
;                   [6] :   RIGHT (upper level under level selection)
;                   [2] :   DOWN
;                   [/] :   MARK SQUARE AS MINED
;
;
;   Memory data:  162 bytes <--- Not a lot, we saw bigger somewhere else !
;          Code:  647 bytes   <--- Small, but surely more optimizable...
;  Program data: 1228 bytes     <--- Well, almost twice the code itself !!!
; Whole program: 1875 bytes   <--- A nice total, for a nice game.
;   Memory used: 2037 bytes  <--- Yop, a 2Kb 'SCHIP' computer would run it !
;
;****************************************************************************


;---------------------------------------------------------------------------
; First of all before programming, the compiler settings
;---------------------------------------------------------------------------

align off      ; No word alignement: we allow 8-bit data
option binary  ; Output format is a BINARY file
option schip11 ; We use the SCHIP instruction set
undef hphead   ; Already said we want a binary file. Compiler is
               ; buggy there, it generates an HP48 file when we
               ; specify that we use SCHIP instruction set...



;---------------------------------------------------------------------------
; For a good understanding of this source,
; let's say what are the registers in the programm.
;---------------------------------------------------------------------------

    ; V0: General use
    ; V1: General use
    ; V2: General use
    ; V3: General use
    ; V4: Used in GetData sub. Contains the mined status at cursor pos.
    ; VA: Remaining non-mined squares to find
    ; VB: Number of mines around the cursor, after having checked
    ; VC: Number of mines
    ; VD: X position of cursor
    ; VE: Y position of cursor
    ; VF: Carry / Borrow / Collision


    JP  Copyright                          ; Before starting all, let's
                                           ; put a little copyright message
    DA 'MINES! 1.00 By David WINTER'       ; in the program. Just to tell
                                           ; one who don't have the source,
Copyright:                                 ; that I'm the author. Heyhey !!!

;---------------------------------------------------------------------------
; First, we have to draw a nice introduction screen.
;---------------------------------------------------------------------------

    HIGH    ; Set graphics mode to 128*64
    CLS     ; Erase the screen

    LD  V0, 0       ; Set V0 and V1 to the locations where
    LD  V1, 0       ; we will draw the 16*16 sprites.
    LD  V2, 32      ; Set V2 to the value making I point on the next sprite
    LD  I, TITLE    ; I points on the bitmaps of the sprites

DrawTitle:
    DRW V0, V1, 0   ; Draw a 16*16 sprite at V0, V1
    ADD I,  V2      ; I points on the next sprite
    ADD V1, 16      ; Compute location of next sprite
    SE  V1, 64      ; Check if the last sprite of the current column is drawn
    JP  DrawTitle   ; If not, continue drawing the 16*64 part of the title

    LD  V1, 0       ; Set V1 to the Y location of the first sprite
    ADD V0, 16      ; Set V0 to the next column location, so 16 pixels right
    SE  V0, 128     ; Check if all the columns are drawn
    JP  DrawTitle   ; If not, continue drawing the title



;---------------------------------------------------------------------------
; And then, the player has to choose the level he wants to play.
; Levels are 1...5, each corresponding to the number of mines on
; the playing field (10...50).
;---------------------------------------------------------------------------

    LD  VC, 1       ; Initial level is 1 (10 mines, disgustingly easy...)
    CALL DrawLevel  ; Let's draw the level on the screen...

ChooseLevel:
    LD  V3, K       ; Keypress...

    SE  V3, 4           ; Key 4 not pressed ?
    JP  NoPreviousLevel ; So don't choose previous level

    CALL DrawLevel  ; Erase old level by drawing it on itself
    ADD VC, #FF     ; Set current level to previous level - 1
    SNE VC, 0       ; If current level is 0, we put it at 5
    LD  VC, 5       ;
    CALL DrawLevel  ; Draw new level

NoPreviousLevel:
    SE  V3, 6           ; Key 6 not pressed ?
    JP  NoNextLevel ; So don't choose next level

    CALL DrawLevel  ; Erase old level by drawing it on itself
    ADD VC, 1       ; Set current level to previous level + 1
    SNE VC, 6       ; If current level is 6, we put it at 1
    LD  VC, 1       ;
    CALL DrawLevel  ; Draw new level


NoNextLevel:
    SE  V3, 5       ; Key 5 not pressed ?
    JP  ChooseLevel ; Continue choosing the level...

    LD  V0, VC  ; Level was 1..5
    ADD VC, VC  ; but we must have
    ADD VC, VC  ; in VC the number
    ADD VC, VC  ; of mines, which
    ADD VC, V0  ; is level*10...
    ADD VC, V0  ; So VC=VC*10...

    LD  VA, 162 ; Put in VA the number of non-mined
    SUB VA, VC  ; squares to find


;---------------------------------------------------------------------------
; Once the player choosed the level he wants to play, we have to draw a
; little message on the screen to tell him that he has to wait while the
; program is choosing the mines on the playing field.
;---------------------------------------------------------------------------

    CLS             ; Erase the screen
    LD  V0, 42      ; Set V0 and V1 to
    LD  V1, 29      ; message location
    LD  V2, 5       ; Set V2 to increment I
    LD  I,  PLEASE  ; I points on message bitmaps

DrawPlease:
    DRW V0, V1, 5   ; Draw a block of the bitmap (8*5)
    ADD I,  V2      ; I points on next block to draw
    ADD V0, 8       ; Set V0 to next block X-location
    SE  V0, 90      ; If V0 is last block+8, all blocks are drawn
    JP  DrawPlease  ; Continue drawing if it is not the case



;---------------------------------------------------------------------------
; Now, we have to erase the data corresponding to the mines.
; We must do this if the player RESETs CHIP-8, else the data
; will be kept, and the program will not be able to choose
; the new locations of the mines.
;---------------------------------------------------------------------------

    LD  I, MINES    ; I points on the mines data
    LD  V0, 0       ; V0 contains the Mine data
    LD  V1, 1       ; V1 contains the I incrementation
    LD  V2, 0       ; V2 contains the number of data erased
EraseData:
    LD  [I], V0     ; Erase data at [I]
    ADD I,  V1      ; I points on next data
    ADD V2, 1       ; Update counter
    SE  V2, 162     ; Are all the data erased ?
    JP  EraseData   ; No, so let's continue erasing them...



;---------------------------------------------------------------------------
; Once the data are erased, the programm can generate
; random locations for the mines. Let's do it !
;---------------------------------------------------------------------------

    LD  V3, 0   ; V3 contains the number of mines allocated

Random:
    LD  I, MINES    ; I points on the mines data
    RND V1, 255     ; Choose random location (0...161)
    LD  V2, 161     ; Last location
    SUB V2, V1      ; Check if location is out of range (>161)
    SE  VF, 1       ; No ? Don't repeat random section
    JP  Random
    ADD I, V1       ; I points on mine data
    LD  V0, [I]     ; Check if a mine is already allocated
    SE  V0, 0       ; Is there a mine in here ?
    JP  Random      ; Yes, so let's choose another location
    LD  V0, 1       ; Loads in V0 the mine data mark
    LD  [I], V0     ; And saves mine data.
    ADD V3, 1       ; Increments the number of mines allocated
    SE  V3, VC      ; All mines done ? So don't allocate anymore
    JP  Random      ; Else, continue allocating



;---------------------------------------------------------------------------
; The mines are now allocated, so the game begins...
; But to play, we need the playing field !
; So, let's draw it... !
;---------------------------------------------------------------------------

    CLS         ; Erase screen, so the previous message

    LD  V0, 0       ; V0 contains the X location of the sprites do draw
    LD  V1, 0       ; Same for V1, with Y
    LD  I,  GRID    ; I points on the grid bitmap

DrawGrid:
    DRW V0, V1, 0   ; Draw a sprite of the grid
    ADD V1, 14      ; Compute location of the next sprite to draw
    SE  V1, 56      ; Is a whole column drawn ?
    JP  DrawGrid    ; No, so let's continue drawing it

    DRW V0, V1, 0   ; Finish drawing it (bottom line, so we can draw a
                    ; 16*16 sprite, as it will not overload the screen

    LD  V1, 0       ; Set V1 to first Y location of sprites
    ADD V0, 14      ; Set V0 to NEXT X location of sprites
                    ; (we prepare to draw the next column)
    SE  V0, 126     ; Check if last column is drawn
    JP  DrawGrid    ; If not, continue drawing...


    LD  I, VLINE    ; I points to the sprite of a vertical line
                    ; because the last column misses it...

DrawVline:
    DRW V0, V1, 8   ; Draw a part of the vertical line
    ADD V1, 8       ; Computes location of next part to draw
    SE  V1, 64      ; Checks if last part is drawn
    JP  DrawVline   ; Continue drawing if not...



;---------------------------------------------------------------------------
; Everything is now ready, so let's play !!!
; Playing consists of moving a cursor which designs
; the location supposed to contain a mine or not.
; So, let's move it... !
;---------------------------------------------------------------------------

    LD  VD, 0       ; Set VD to initial X location of cursor
    LD  VE, 0       ; And so on for VE with Y

    CALL    DrawBox ; We draw the cursor at VD*7, VE*7
                    ; (Yes, you guessed: cursor coordinates
                    ; range from 0 to 17/8 for VD/VE)

Move:
    LD  V2, K   ; Let's allow the player to press a key
    SE  V2, 2   ; Is the key UP pressed ?
    JP  NoUp    ; No, so let's look for the others...

    CALL DrawBox    ; Erase the cursor by drawing it on itself
    ADD VE, #FF     ; Move it UP, so compute its next Y location
    SNE VE, #FF     ; Was it at its upper position ?
    LD  VE, 8       ; Yes, so let's put it at the downer one...
    CALL DrawBox    ; And draw cursor at its next position

NoUp:
    SE  V2, 4   ; Is the key LEFT pressed ?
    JP  NoLeft  ; No, so let's look for the others...

    CALL DrawBox    ; Erase the cursor by drawing it on itself
    ADD VD, #FF     ; Move it LEFT, so compute its next X location
    SNE VD, #FF     ; Was it on the leftmost location  ?
    LD  VD, 17      ; Yes, so let's put it at the rightmost one...
    CALL DrawBox    ; And draw cursor at its next position

NoLeft:
    SE  V2, 6   ; Is the key RIGHT pressed ?
    JP  NoRight ; No, so let's look for the others...

    CALL DrawBox    ; Erase the cursor by drawing it on itself
    ADD VD, 1       ; Move it RIGHT, so compute its next X location
    SNE VD, 18      ; Was it on the rightmost location ?
    LD  VD, 0       ; Yes, so let's put it at the leftmost one...
    CALL DrawBox    ; And draw cursor at its next position

NoRight:
    SE  V2, 8   ; Is the key RIGHT pressed ?
    JP  NoDown  ; No, so let's look for the others...

    CALL DrawBox    ; Erase the cursor by drawing it on itself
    ADD VE, 1       ; Move it DOWN, so compute its next Y location
    SNE VE, 9       ; Was it on the downer location ?
    LD  VE, 0       ; Yes, so let's put it at the upper one...
    CALL DrawBox    ; And draw cursor at its next position

NoDown:
    SE  V2, 12  ; Is the key C (MARK MINE) pressed ?
    JP  NoMark  ; No, so don't mark/unmark square

    CALL GetData ; Get square state into V0

    LD  V1, V0  ; Saves V0 into V1
    LD  V2, 2   ; V2 contains the mask of bit 1
    AND V1, V2  ; Keeps only bit 1 of V1, which tells if the square is played
    SNE V1, 2   ; So checks if the square has already been played
    JP  NoMark  ; And skips mark/unmark routine if so

    LD  V1, 4       ; V1 contains the mask for bit 2
    XOR V0, V1      ; Invert the state of bit 2 of V0, so the mark state
    LD  [I], V0     ; And saves the data of the square
    CALL DrawBox2   ; Erases the bitmap of the square
    CALL DrawMark   ; And replaces it by the mark

        ; Bit 0: Indicates if the square has a mine or not
        ; Bit 1: Indicates that the square has been checked
        ; Bit 2: Indicates that the square has been marked as mined

NoMark:
    SE  V2, 5   ; Last possible key 5 (SHOW if there's a mine or not)
    JP  Move    ; It it is not it, let's continue moving the cursor



;---------------------------------------------------------------------------
; Now that we moved the cursor where we suppose that there is no mine,
; we have to know if there is one or not.
; If there is no mine, the program tells how many they are around the cursor.
; Else, it shows all of them, and game over... Right ?
;---------------------------------------------------------------------------

    CALL GetData    ; Get the status of the square pointed by the cursor
    LD  V3, V0      ; Saves it into V3
    LD  V2, 2       ; Load into V2 the mask of Bit 1
    AND V3, V2      ; AND V3 with V2, to keep only Bit 1 of V3
    SNE V3, 2       ; Check if the square has already been played
    JP  Move        ; If so, don't check again, continue moving around...

    OR  V0, V2      ; Set bit 2 of V0 at 1, as the square is now checked
    LD  [I], V0     ; And save the data

    CALL DrawBox    ; We erase the cursor


    CALL GetData    ; Get the status of the square pointed by the cursor
    LD  V3, V0      ; Get again V0 into V3
    LD  V2, 1       ; Set mask for bit 0
    AND V3, V2      ; Keep bit 0 of V3
    SNE V3, 1       ; Check if there was a mine
    JP  Lost        ; If so, show the mines and game over


    CALL GetData    ; Get the status of the square pointed by the cursor
    LD  V3, V0      ; Once again, get V0 into V3
    LD  V2, 4       ; Set mask for bit 2
    AND V3, V2      ; And keep bit 2 of V3
    SNE V3, 4       ; And check if the square is MARKED as mined
    CALL DrawMark   ; If yes, erase the mark by drawing it on itself

    SNE V3, 0       ; If the square is not marked,
    CALL DrawBox2   ; Erase the square.


    LD  VB, 0       ; Sets the initial number of mines to 0


;---------------------------------------------------------------------------
; Checking the number of mines around the squares requires verifications
; of the position of the cursor, because we must not check the locations
; which are outside the playing field.
;---------------------------------------------------------------------------


    SNE VD, 0           ; Checks the square located up-left.
    JP  NoUpLeftSquare  ; To do so, the cursor must not be
    SNE VE, 0           ; placed on the first line and/or
    JP  NoUpLeftSquare  ; the first column.

    ADD VD, #FF     ; Sets cursor coords to these of the
    ADD VE, #FF     ; up-left square.
    CALL GetData    ; Get mine status at this location and add it to VB
    ADD VD, 1       ; And restore the cursor
    ADD VE, 1       ; coords.


NoUpLeftSquare:

    SNE VE, 0       ; To check the square just over the cursor,
    JP  NoUpSquare  ; the cursor must not be on the first line.

    ADD VE, #FF   ; Set cursor to location over it
    CALL GetData  ; Checks mine status there and add it to VB
    ADD VE, 1     ; Restore cursor coords


NoUpSquare:

    SNE VD, 17           ; To check the square up-right placed,
    JP  NoUpRightSquare  ; the cursor must not be top-right
    SNE VE, 0            ; and/or top-up placed.
    JP  NoUpRightSquare  ;

    ADD VD, 1       ; Place cursor on the square to check
    ADD VE, #FF     ;
    CALL GetData    ; Checks mine status...
    ADD VD, #FF     ; Restore cursor coords...
    ADD VE, 1       ;


NoUpRightSquare:

    SNE VD, 0         ; Check if we can look at the left square
    JP  NoLeftSquare  ; No, so check the next one

    ADD VD, #FF   ;
    CALL GetData  ; Get mine status...
    ADD VD, 1     ;


NoLeftSquare:

    SNE VD, 17         ; Can we check square on the right  ?
    JP  NoRightSquare  ; No, so don't...

    ADD VD, 1    ;
    CALL GetData ; Get mine status...
    ADD VD, #FF  ;


NoRightSquare:

    SNE VD, 0              ; If the cursor is not placed on the
    JP  NoDownLeftSquare   ; last line, and/or on the first
    SNE VE, 8              ; column, we can check the square
    JP  NoDownLeftSquare   ; down-left of the cursor...

    ADD VD, #FF   ; Set cursor coords to these
    ADD VE, 1     ; of the square to check
    CALL GetData  ; Get mine status there...
    ADD VD, 1     ; Restore cursor coords...
    ADD VE, #FF   ;


NoDownLeftSquare:

    SNE VE, 8         ; Can we check the square down the cursor ?
    JP  NoDownSquare  ; No, so don't...

    ADD VE, 1     ;
    CALL GetData  ; Checks the mine status there...
    ADD VE, #FF   ;


NoDownSquare:

    SNE VD, 17              ; To check the square placed down-right
    JP  NoDownRightSquare   ; from the cursor, the cursor must not
    SNE VE, 8               ; be placed on the last line, and/or on
    JP  NoDownRightSquare   ; the last column

    ADD VD, 1     ; Set cursor coords to these of
    ADD VE, 1     ; the square we want to check
    CALL GetData  ; Get the mine status there...
    ADD VD, #FF   ; And restore cursor coords...
    ADD VE, #FF   ;


NoDownRightSquare:

    SNE VB, 0   ; No mines around the cursor ?
    JP  NoMine  ; So don't draw the number...

    ADD VB, #FF     ; Substract 1 to the number of mines
    LD  I, NUMBERS  ; I points on the first number bitmap,
    LD  V0, VB      ; which is 1 (this is why we substract 1...).
    ADD V0, V0      ; Get the number of mines - 1 in V0
    ADD V0, V0      ; and multiply V0 by 7, as the bitmap
    ADD V0, V0      ; of the numbers are 8*7 pixels big.
    SUB V0, VB      ;
    ADD I,  V0      ; Make I point on the number
    CALL DrawIt     ; And draw it !!!

NoMine:
    CALL DrawBox    ; Erase the cursor
    ADD VA, #FF     ; Decrements the number of non-mined squares to find
    SE  VA, 0       ; Checks if all of them are found
    JP  Move        ; If not, continue playing

    CALL DrawBox    ; Erase the cursor
    JP  FIN         ; Else, the game ends for now...

Lost:
    LD  VD, 0   ; Set cursor coords to first square of the playing field
    LD  VE, 0   ;

ShowMines:
    CALL GetData    ; Get square status at cursor location
    LD  V1, 1       ; Set V1 to bit 0 mask
    AND V0, V1      ; Keep bit 0 of V0, so the mine status
    SE  V0, 1       ; Checks if there is a mine
    JP  NoMineHere  ; Don't draw mine if not.

    CALL GetData    ; Get again data of square
    LD  V1, 4       ; Set V1 to mask of bit 2
    AND V0, V1      ; Keeps bit 2 of V0, so the mark status
    LD  V3, V0      ; Saves V0 into V3
    SNE V0, 4       ; If there is a mark...
    CALL DrawMark   ; ... erase it

    SE V3, 4        ; If there is no mark...
    CALL DrawBox2   ; ... erase the cursor

    LD  I, MINE     ; And finally, draw the mine !!!
    CALL DrawIt     ;

NoMineHere:
    ADD VD, 1       ; Compute next square to check
    SE  VD, 18      ; If we didn't check the last square of current row,
    JP  ShowMines   ; continue checking the squares of the row

    LD  VD, 0     ; Points cursor on first X location of the squares in the row
    ADD VE, 1     ; Points cursor on the next row
    SE  VE, 9     ; Check if the last row was checked
    JP  ShowMines ; Continue checking if not...

Fin:    JP Fin  ; Game over loop. Press RESET to replay...


;---------------------------------------------------------------------------
; GetData: Subroutine to get the value corresponding to the square
;          pointed by the cursor.
;          This subroutine adds 1 or 0 to VB if there is a mine of not.
;          If this subroutine is called outside the routine which checks
;          the number of mines around the cursor, VB is modified.
;---------------------------------------------------------------------------

GetData:
    LD  I, MINES    ; I points on the playing field data
    LD  V0, VE      ;
    ADD V0, V0      ; Here, we set V0 to 18*VD + VE
    ADD V0, V0      ; by performing 16*VD + VD + VD + VE
    ADD V0, V0      ;
    ADD V0, V0      ;
    ADD V0, VE      ;
    ADD V0, VE      ;
    ADD V0, VD      ;
    ADD I,  V0      ; Makes I point on correct square data
    LD  V0, [I]     ; And loads into V0 the data

    LD  V1, V0  ; Saves the data in V1
    LD  V4, 1   ; Loads in V4 the mask of bit 0
    AND V1, V4  ; Keeps bit 0 of V1, so the mine status
    ADD VB, V1  ; And add mine status to VB

    RET     ; Return...


;---------------------------------------------------------------------------
; DrawMark: Subroutine to draw a mine mark at location at VD*7, VE*7
;           (The RET instruction is after the DrawIt ones...)
;---------------------------------------------------------------------------

DrawMark:
    LD  I, MARK ; I points on the bitmap of the square
    JP  DrawIt  ; And let's draw the square...


;---------------------------------------------------------------------------
; DrawBox2: Subroutine to draw the square at location at VD*7, VE*7
;           (The RET instruction is after the DrawIt ones...)
;---------------------------------------------------------------------------

DrawBox2:
    LD  I, BOX2 ; I points on the bitmap of the square
    JP  DrawIt  ; And let's draw the square...


;---------------------------------------------------------------------------
; DrawBox: Subroutine to draw the cursor at location at VD*7, VE*7
;---------------------------------------------------------------------------

DrawBox:
    LD  I, BOX ; Guess... You're not so stupid, are you ???
DrawIt:
    LD  V0, VD  ; V0 contains VD
    LD  V1, VE  ; V0 contains VE

    ADD V0, V0  ; V0 must be VD*7, which is in fact VD*8 - VD
    ADD V0, V0  ; SO...
    ADD V0, V0  ;      ... LET'S...
    SUB V0, VD  ;                  ... DO IT ...

    ADD V1, V1  ; And for V1, it must be VE*7...
    ADD V1, V1  ; But I won't explain, it is written just
    ADD V1, V1  ; before... OK ?
    SUB V1, VE  ;

    DRW V0, V1, 8 ; And finnnnnnallllllly, we draw what we're suppose to draw
    RET           ; And we return from the subroutine. Yes, we must do it...



;---------------------------------------------------------------------------
; DrawLevel: Draw the level on the title
;---------------------------------------------------------------------------

DrawLevel:
    LD  V0, 86      ; Set V0 and V1 to the locations
    LD  V1, 47      ; where the level will be displayed.
    LD  I,  LEVELS  ; I points on the level 1 bitmap.

    LD  V2, VC      ; Oh, well... The bitmap of each level is 8*9 pixels.
    ADD V2, V2      ; So, depending on the current level, we have to
    ADD V2, V2      ; make I point on the correct bitmap. So as I points
    ADD V2, V2      ; on level 1 by default, we have to move I on the
    ADD V2, VC      ; good level bitmap, so add 9*(level-1) to I.
    ADD V2, #F7     ; So we perform V2 = (V2 * 8) + V2, with V2 = level
                    ; As V2 = level, we must sbstract 9 to V2, to point
                    ; on level-1.

    ADD I,  V2      ; We add V2 to I
    DRW V0, V1, 9   ; And draw the level. Great !
    RET             ; Guess...



;---------------------------------------------------------------------------
; Now that the program is finished, it would have been too nice to have a
; so little code. So let's waste some memory with data, corresponding to
; the mines and the different bitmaps to draw.
;---------------------------------------------------------------------------

GRID:
    DW  $11111111111111..
    DW  $11.1.1.11.1.1...
    DW  $1.1.1.11.1.1.1..
    DW  $11.1.1.11.1.1...
    DW  $1.1.1.11.1.1.1..
    DW  $11.1.1.11.1.1...
    DW  $1.1.1.11.1.1.1..
    DW  $11111111111111..
    DW  $11.1.1.11.1.1...
    DW  $1.1.1.11.1.1.1..
    DW  $11.1.1.11.1.1...
    DW  $1.1.1.11.1.1.1..
    DW  $11.1.1.11.1.1...
    DW  $1.1.1.11.1.1.1..
    DW  $0,0

VLINE:
    DB  $1.......
    DB  $1.......
    DB  $1.......
    DB  $1.......
    DB  $1.......
    DB  $1.......
    DB  $1.......
    DB  $1.......

BOX:
    DB  $11111111
    DB  $11111111
    DB  $11111111
    DB  $11111111
    DB  $11111111
    DB  $11111111
    DB  $11111111
    DB  $11111111

MARK:
    DB  $........
    DB  $........
    DB  $...11...
    DB  $..1111..
    DB  $..1111..
    DB  $...11...
    DB  $........
    DB  $........

MINE:
    DB  $........
    DB  $...11...
    DB  $..1111..
    DB  $.111111.
    DB  $.111111.
    DB  $..1111..
    DB  $...11...
    DB  $........

BOX2:
    DB  $........
    DB  $.1.1.1..
    DB  $..1.1.1.
    DB  $.1.1.1..
    DB  $..1.1.1.
    DB  $.1.1.1..
    DB  $..1.1.1.
    DB  $........

NUMBERS:
    DB  $........
    DB  $.111.11.
    DB  $.11..11.
    DB  $.1.1.11.
    DB  $.111.11.
    DB  $.111.11.
    DB  $.1....1.
    DB  $........
    DB  $.11..11.
    DB  $.1.11.1.
    DB  $.1111.1.
    DB  $.11..11.
    DB  $.1.1111.
    DB  $.1....1.
    DB  $........
    DB  $.1...11.
    DB  $.1111.1.
    DB  $.1111.1.
    DB  $.1...11.
    DB  $.1111.1.
    DB  $.1...11.
    DB  $........
    DB  $.1.11.1.
    DB  $.1.11.1.
    DB  $.1.11.1.
    DB  $.11...1.
    DB  $.1111.1.
    DB  $.1111.1.
    DB  $........
    DB  $.1....1.
    DB  $.1.1111.
    DB  $.1...11.
    DB  $.1111.1.
    DB  $.1111.1.
    DB  $.1...11.
    DB  $........
    DB  $.11...1.
    DB  $.1.1111.
    DB  $.1...11.
    DB  $.1.11.1.
    DB  $.1.11.1.
    DB  $.11..11.
    DB  $........
    DB  $.1....1.
    DB  $.1111.1.
    DB  $.111..1.
    DB  $.11..11.
    DB  $.11.111.
    DB  $.11.111.
    DB  $........
    DB  $.11..11.
    DB  $.1.11.1.
    DB  $.1.11.1.
    DB  $.11..11.
    DB  $.1.11.1.
    DB  $.11..11.
    DB  $........

PLEASE:
    DB $111.1...
    DB $1.1.1...
    DB $111.1...
    DB $1...1...
    DB $1...111.

    DB $111.111.
    DB $1...1.1.
    DB $11..111.
    DB $1...1.1.
    DB $111.1.1.

    DB $111.111.
    DB $1...1...
    DB $111.11..
    DB $..1.1...
    DB $111.111.

    DB $...1...1
    DB $...1...1
    DB $...1.1.1
    DB $...11.11
    DB $...1...1

    DB $.111.111
    DB $.1.1..1.
    DB $.111..1.
    DB $.1.1..1.
    DB $.1.1.111

    DB $.111....
    DB $..1.....
    DB $..1.....
    DB $..1.....
    DB $..1.....


TITLE:
    DW $................
    DW $................
    DW $................
    DW $................
    DW $........1111111.
    DW $..........11111.
    DW $...........1111.
    DW $...........11111
    DW $...........1.111
    DW $...........1.111
    DW $...........1..11
    DW $...........1..11
    DW $...........1..11
    DW $...........1...1
    DW $...........1...1
    DW $...........1....

    DW $...........1....
    DW $...........1....
    DW $...........1....
    DW $...........1....
    DW $...........1....
    DW $...........1....
    DW $...........1....
    DW $...........1....
    DW $..........111...
    DW $........1111111.
    DW $................
    DW $................
    DW $................
    DW $................
    DW $.........111111.
    DW $...........11...

    DW $...........11...
    DW $...........11...
    DW $...........11...
    DW $...........11...
    DW $...........11...
    DW $...........11...
    DW $...........11...
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $................
    DW $................
    DW $................
    DW $................
    DW $............1111
    DW $............1111
    DW $...........1111.
    DW $...........1111.
    DW $...........1111.
    DW $1.........11111.
    DW $1.........11111.
    DW $1........1..111.
    DW $11.......1..111.
    DW $11.......1..111.
    DW $111.....1...111.
    DW $111.....1...111.

    DW $111....1....111.
    DW $1111...1....111.
    DW $.111...1....111.
    DW $.1111.1.....111.
    DW $..111.1.....111.
    DW $..1111......111.
    DW $...111......111.
    DW $...111......111.
    DW $....1......11111
    DW $....1....1111111
    DW $................
    DW $................
    DW $................
    DW $................
    DW $.11.............
    DW $.11.............

    DW $.11111....1111..
    DW $.11..11..11..11.
    DW $.11..11..11..11.
    DW $.11..11..111111.
    DW $.11..11..11.....
    DW $.11..11..11.....
    DW $.11..11...1111..
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $...........11111
    DW $...........1....
    DW $...........1....
    DW $...........1.111

    DW $...........1...1
    DW $...........1...1
    DW $...........1...1
    DW $...........1...1
    DW $...........1...1
    DW $...........1...1
    DW $...........1...1
    DW $...........1.111
    DW $...........1....
    DW $...........1....
    DW $...........11111
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $................
    DW $................
    DW $................
    DW $................
    DW $11..111111111..1
    DW $......11111.....
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......

    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $.......111......
    DW $......11111.....
    DW $11..111111111..1
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $.........111111.
    DW $.........11.1.11
    DW $.........11.1.11
    DW $.........11.1.11
    DW $.........11.1.11
    DW $.........11.1.11
    DW $.........11...11
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $1111111111111111
    DW $................
    DW $................
    DW $11...1111111.111

    DW $......1....1..1.
    DW $......1.......1.
    DW $......1..1....1.
    DW $......1111.....1
    DW $......1..1.....1
    DW $......1........1
    DW $...1..1....1....
    DW $1111.1111111....
    DW $................
    DW $................
    DW $1111111111111111
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $................
    DW $................
    DW $................
    DW $................
    DW $1111.........111
    DW $.1111..........1
    DW $..1111..........
    DW $..1111..........
    DW $..11111.........
    DW $..1.1111........
    DW $..1..1111.......
    DW $..1..1111.......
    DW $..1...1111......
    DW $..1....1111.....
    DW $..1.....1111....
    DW $..1.....1111....

    DW $..1......1111...
    DW $..1.......1111..
    DW $..1........1111.
    DW $..1........1111.
    DW $..1.........1111
    DW $..1..........111
    DW $..1...........11
    DW $..1...........11
    DW $.111...........1
    DW $111111..........
    DW $................
    DW $................
    DW $................
    DW $...11...........
    DW $...11...........
    DW $................

    DW $.1111....11111..
    DW $...11....11..11.
    DW $...11....11..11.
    DW $...11....11..11.
    DW $...11....11..11.
    DW $...11....11..11.
    DW $.111111..11..11.
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $1111111111111111
    DW $................
    DW $................
    DW $.111.1111111.111

    DW $..1...1....1...1
    DW $..1...1........1
    DW $..1...1..1.....1
    DW $.1....1111.....1
    DW $.1....1..1.....1
    DW $.1....1........1
    DW $1.....1....1...1
    DW $1....1111111.111
    DW $................
    DW $................
    DW $1111111111111111
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $................
    DW $................
    DW $................
    DW $................
    DW $1111..1111111111
    DW $11......11111...
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........1111111
    DW $1........111....

    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1........111....
    DW $1.......11111...
    DW $1.....1111111111
    DW $................
    DW $................
    DW $................
    DW $................
    DW $.........11.....
    DW $.........11.....

    DW $..1111...11111..
    DW $.11..11..11..11.
    DW $.11..11..11..11.
    DW $.111111..11..11.
    DW $.11......11..11.
    DW $.11......11..11.
    DW $..1111...11..11.
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $1111111111111111
    DW $................
    DW $................
    DW $11..............

    DW $................
    DW $................
    DW $........1.......
    DW $................
    DW $................
    DW $................
    DW $...1............
    DW $1111....1.......
    DW $................
    DW $................
    DW $1111111111111111
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $................
    DW $................
    DW $................
    DW $................
    DW $111111.........1
    DW $....11.......111
    DW $.....1......111.
    DW $.....1......111.
    DW $...........1111.
    DW $...........1111.
    DW $...........1111.
    DW $...1........1111
    DW $...1........1111
    DW $..11.........111
    DW $1111..........11
    DW $..11............

    DW $...1............
    DW $...1............
    DW $................
    DW $................
    DW $...........1....
    DW $...........1....
    DW $.......1...11...
    DW $......11...111..
    DW $....111....1111.
    DW $1111111....1..11
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $.11..11..11111..
    DW $.11..11..11..11.
    DW $.11..11..11..11.
    DW $.11..11..11..11.
    DW $.11..11..11..11.
    DW $.11..11..11..11.
    DW $..11111..11..11.
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $1111111111111111
    DW $................
    DW $................
    DW $...............1

    DW $..............1.
    DW $..............1.
    DW $..............1.
    DW $..............1.
    DW $..............1.
    DW $..............1.
    DW $..............1.
    DW $...............1
    DW $................
    DW $................
    DW $1111111111111111
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $................
    DW $................
    DW $................
    DW $................
    DW $11111..1........
    DW $....1111........
    DW $......11........
    DW $.......1........
    DW $.......1........
    DW $................
    DW $................
    DW $................
    DW $11..............
    DW $1111............
    DW $11111...........
    DW $1111111.........

    DW $.1111111........
    DW $...11111........
    DW $....11111.......
    DW $.....1111.......
    DW $.....1111.......
    DW $.....1111.......
    DW $.....111........
    DW $.....111........
    DW $....111.........
    DW $11111...........
    DW $................
    DW $................
    DW $................
    DW $................
    DW $..11............
    DW $..11............

    DW $.111111...1111..
    DW $..11.....11..11.
    DW $..11.....11..11.
    DW $..11.....111111.
    DW $..11.....11.....
    DW $..11.....11.....
    DW $...1111...1111..
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $11111...........
    DW $....1...........
    DW $....1...........
    DW $11..1...........

    DW $..1.1...........
    DW $..1.1...........
    DW $..1.1...........
    DW $..1.1...........
    DW $..1.1...........
    DW $..1.1...........
    DW $..1.1...........
    DW $11..1...........
    DW $....1...........
    DW $....1...........
    DW $11111...........
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $................
    DW $................
    DW $................
    DW $......1.........
    DW $.....111........
    DW $.....111........
    DW $.....111........
    DW $.....111........
    DW $.....111........
    DW $.....111........
    DW $.....111........
    DW $.....111........
    DW $.....111........
    DW $......1.........
    DW $......1.........
    DW $......1.........

    DW $......1.........
    DW $......1.........
    DW $................
    DW $................
    DW $................
    DW $................
    DW $......1.........
    DW $.....111........
    DW $.....111........
    DW $......1.........
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $.11..11.........
    DW $.11.111.........
    DW $.111............
    DW $.11.............
    DW $.11.............
    DW $.11.............
    DW $.11.............
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................

    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................
    DW $................


LEVELS:
    DB $..1.....
    DB $111.....
    DB $..1.....
    DB $..1.....
    DB $..1.....
    DB $..1.....
    DB $..1.....
    DB $..1.....
    DB $11111...

    DB $.111....
    DB $1...1...
    DB $....1...
    DB $....1...
    DB $...1....
    DB $..1.....
    DB $.1......
    DB $1.......
    DB $11111...

    DB $.111....
    DB $1...1...
    DB $....1...
    DB $....1...
    DB $..11....
    DB $....1...
    DB $....1...
    DB $1...1...
    DB $.111....

    DB $...1....
    DB $..11....
    DB $..11....
    DB $.1.1....
    DB $.1.1....
    DB $1..1....
    DB $11111...
    DB $...1....
    DB $..111...

    DB $11111...
    DB $1.......
    DB $1.......
    DB $1.......
    DB $1111....
    DB $....1...
    DB $....1...
    DB $1...1...
    DB $.111....


MINES:
        ; It is in this area that the data (corresponding
        ; to the squares of the playing field) are stored.
        ; Their format is as follow:
        ;       
        ; Bit 0: Indicates if the square a mine or not
        ; Bit 1: Indicates that the square has been checked
        ; Bit 2: Indicates that the square has been marked as mined
          

