package lib

import (
	"fmt"
	"strings"
)

const (
	GfxW = 128      //gfx width
	GfxH = 64       //gfx height
	GfxS = 128 * 64 //gfx size
)

var (
	fontLoRes = []byte{
		0xF0, 0x90, 0x90, 0x90, 0xF0, // 0 Mem[0x00]:Mem[0x04]
		0x20, 0x60, 0x20, 0x20, 0x70, // 1 Mem[0x05]:Mem[0x09]
		0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2 Mem[0x0A]:Mem[0x0E]
		0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3 Mem[0x0F]:Mem[0x13]
		0x90, 0x90, 0xF0, 0x10, 0x10, // 4 Mem[0x14]:Mem[0x18]
		0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5 Mem[0x19]:Mem[0x1D]
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6 Mem[0x1E]:Mem[0x22]
		0xF0, 0x10, 0x20, 0x40, 0x40, // 7 Mem[0x23]:Mem[0x27]
		0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8 Mem[0x28]:Mem[0x2C]
		0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9 Mem[0x2D]:Mem[0x31]
		0xF0, 0x90, 0xF0, 0x90, 0x90, // A Mem[0x32]:Mem[0x36]
		0xE0, 0x90, 0xE0, 0x90, 0xE0, // B Mem[0x37]:Mem[0x3B]
		0xF0, 0x80, 0x80, 0x80, 0xF0, // C Mem[0x3C]:Mem[0x40]
		0xE0, 0x90, 0x90, 0x90, 0xE0, // D Mem[0x41]:Mem[0x45]
		0xF0, 0x80, 0xF0, 0x80, 0xF0, // E Mem[0x46]:Mem[0x4A]
		0xF0, 0x80, 0xF0, 0x80, 0x80, // F Mem[0x4B]:Mem[0x4F]
	}
	fontHiRes = []byte{
		0xff, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xff, // 0
		0x18, 0x78, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0xff, // 1
		0xff, 0xff, 0x03, 0x03, 0xff, 0xff, 0xc0, 0xc0, 0xff, 0xff, // 2
		0xff, 0xff, 0x03, 0x03, 0xff, 0xff, 0x03, 0x03, 0xff, 0xff, // 3
		0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xff, 0x03, 0x03, 0x03, 0x03, // 4
		0xff, 0xff, 0xc0, 0xc0, 0xff, 0xff, 0x03, 0x03, 0xff, 0xff, // 5
		0xff, 0xff, 0xc0, 0xc0, 0xff, 0xff, 0xc3, 0xc3, 0xff, 0xff, // 6
		0xff, 0xff, 0x03, 0x03, 0x06, 0x0c, 0x18, 0x18, 0x18, 0x18, // 7
		0xff, 0xff, 0xc3, 0xc3, 0xff, 0xff, 0xc3, 0xc3, 0xff, 0xff, // 8
		0xff, 0xff, 0xc3, 0xc3, 0xff, 0xff, 0x03, 0x03, 0xff, 0xff, // 9
		0x7e, 0xff, 0xc3, 0xc3, 0xc3, 0xff, 0xff, 0xc3, 0xc3, 0xc3, // A
		0xfc, 0xfc, 0xc3, 0xc3, 0xfc, 0xfc, 0xc3, 0xc3, 0xfc, 0xfc, // B
		0x3c, 0xff, 0xc3, 0xc0, 0xc0, 0xc0, 0xc0, 0xc3, 0xff, 0x3c, // C
		0xfc, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xfc, // D
		0xff, 0xff, 0xc0, 0xc0, 0xff, 0xff, 0xc0, 0xc0, 0xff, 0xff, // E
		0xff, 0xff, 0xc0, 0xc0, 0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, // F
	}
	opcodeExecutors map[uint16]opcodeExecutor
)

type Chip8 struct {
	Mem  [4096]byte //system memory (4kb total. 0x200-0xFFF: rom and ram)
	Gfx  [GfxS]byte //vF is set upon pixel collision in draw instruction
	pc   uint16     //program counter
	oc   uint16     //current opcode (each opcode is two bytes long)
	vr   [16]byte   //v registers (v0-vE: general purpose. vF: carry flag)
	ir   uint16     //index register
	stk  [16]uint16 //store program counter in stack before jump/gosub
	sp   uint16     //stack pointer to remember the level of stack used
	Key  [16]byte   //stores the current state of the hex keypad (0-F)
	dt   byte       //delay timer counts down to zero at 60hz
	St   byte       //sound timer counts down to zero at 60hz
	Rg   bool       //redraw gfx - set by 0x00E0 (cls) and 0xDXYN (sprite)
	mode mode       //mode - CHIP-8/S-CHIP(LO-RES)/S-CHIP(HI-RES)
}

type opcodeExecutor func()

func NewChip8() *Chip8 {
	vm := Chip8{
		pc: 0x0200,
		St: 15,
		Rg: true,
	}
	//load lo-res font data into first 80 bytes of memory (referenced by FX29)
	for i := 0; i < len(fontLoRes); i++ {
		vm.Mem[i] = fontLoRes[i]
	}
	//load hi-res font data into next 160 bytes of memory (referenced by FX30)
	for i := 0; i < len(fontHiRes); i++ {
		vm.Mem[80+i] = fontHiRes[i]
	}
	opcodeExecutors = map[uint16]opcodeExecutor{
		0x0000: vm.exec0NNN, 0x00C0: vm.exec00CN, 0x00E0: vm.exec00E0,
		0x00EE: vm.exec00EE, 0x00FB: vm.exec00FB, 0x00FC: vm.exec00FC,
		0x00FD: vm.exec00FD, 0x00FE: vm.exec00FE, 0x00FF: vm.exec00FF,
		0x1000: vm.exec1NNN, 0x2000: vm.exec2NNN, 0x3000: vm.exec3XNN,
		0x4000: vm.exec4XNN, 0x5000: vm.exec5XY0, 0x6000: vm.exec6XNN,
		0x7000: vm.exec7XNN, 0x8000: vm.exec8XY0, 0x8001: vm.exec8XY1,
		0x8002: vm.exec8XY2, 0x8003: vm.exec8XY3, 0x8004: vm.exec8XY4,
		0x8005: vm.exec8XY5, 0x8006: vm.exec8XY6, 0x8007: vm.exec8XY7,
		0x800E: vm.exec8XYE, 0x9000: vm.exec9XY0, 0xA000: vm.execANNN,
		0xB000: vm.execBNNN, 0xC000: vm.execCXNN, 0xD000: vm.execDXYN,
		0xE09E: vm.execEX9E, 0xE0A1: vm.execEXA1, 0xF007: vm.execFX07,
		0xF00A: vm.execFX0A, 0xF015: vm.execFX15, 0xF018: vm.execFX18,
		0xF01E: vm.execFX1E, 0xF029: vm.execFX29, 0xF030: vm.execFX30,
		0xF033: vm.execFX33, 0xF055: vm.execFX55, 0xF065: vm.execFX65,
		0xF075: vm.execFX75, 0xF085: vm.execFX85,
	}
	return &vm
}

func (vm *Chip8) DebugInfo() string {
	b := strings.Builder{}
	b.WriteString(fmt.Sprintf("oc:%04X pc:%04X vr:", vm.oc, vm.pc))
	for i := 0; i < len(vm.vr); i++ {
		b.WriteString(fmt.Sprintf("%02X ", vm.vr[i]))
	}
	b.WriteString(fmt.Sprintf("ir:%04X key:", vm.ir))
	for i := 0; i < len(vm.Key); i++ {
		b.WriteString(fmt.Sprintf("%d", vm.Key[i]))
	}
	b.WriteString(fmt.Sprintf(" dt:%02X st:%02X rg:%t", vm.dt, vm.St, vm.Rg))
	return b.String()
}

func (vm *Chip8) EmulateCycle() {
	vm.oc = vm.fetchOpcode()
	d := vm.decodeOpcode()
	opcodeExecutors[d]()
}

func (vm *Chip8) fetchOpcode() uint16 {
	/*
		Fetch opcode:
		Fetch and merge two bytes from memory locations pointed at by pc & pc+1
		e.g. memory[pc] = 0b10100010, memory[pc+1] = 0b11110000
		Convert first byte to uint16 and shift the bits left 8 times.
		e.g. 0b1010001000000000
		Use bitwise OR operation to merge the bytes.
		e.g. 0b1010001000000000 | 0b11110000 = 0b1010001011110000
	*/
	return uint16(vm.Mem[vm.pc])<<8 | uint16(vm.Mem[vm.pc+1])
}

func (vm *Chip8) decodeOpcode() uint16 {
	/*
		Decode opcode:
		Read the first 4 bits of the current opcode using bitwise AND operation
		e.g. 0x2105 & 0xF000 = 0x2000
		We can't always rely on just the first nibble to decode opcodes
		e.g. 0x00E0 and 0x00EE both start with 0x0
		In these cases we go on to compare the last nibble or byte...
		e.g. 0x00EE & 0x00FF = 0x00EE
	*/
	d := vm.oc & 0xF000
	switch d {
	case 0x0000:
		switch vm.oc & 0x00F0 {
		case 0x00C0:
			d = 0x00C0
		case 0x00E0:
			switch vm.oc & 0x000F {
			case 0x0000:
				d = 0x00E0
			case 0x000E:
				d = 0x00EE
			}
		case 0x00F0:
			switch vm.oc & 0x000F {
			case 0x000B:
				d = 0x00FB
			case 0x000C:
				d = 0x00FC
			case 0x000D:
				d = 0x00FD
			case 0x000E:
				d = 0x00FE
			case 0x000F:
				d = 0x00FF
			}
		}
	case 0x8000:
		switch vm.oc & 0x000F {
		case 0x0000:
			d = 0x8000
		case 0x0001:
			d = 0x8001
		case 0x0002:
			d = 0x8002
		case 0x0003:
			d = 0x8003
		case 0x0004:
			d = 0x8004
		case 0x0005:
			d = 0x8005
		case 0x0006:
			d = 0x8006
		case 0x0007:
			d = 0x8007
		case 0x000E:
			d = 0x800E
		}
	case 0xE000:
		switch vm.oc & 0x00FF {
		case 0x009E:
			d = 0xE09E
		case 0x00A1:
			d = 0xE0A1
		}
	case 0xF000:
		switch vm.oc & 0x00FF {
		case 0x0007:
			d = 0xF007
		case 0x000A:
			d = 0xF00A
		case 0x0015:
			d = 0xF015
		case 0x0018:
			d = 0xF018
		case 0x001E:
			d = 0xF01E
		case 0x0029:
			d = 0xF029
		case 0x0030:
			d = 0xF030
		case 0x0033:
			d = 0xF033
		case 0x0055:
			d = 0xF055
		case 0x0065:
			d = 0xF065
		case 0x0075:
			d = 0xF075
		case 0x0085:
			d = 0xF085
		}
	}
	return d
}

func (vm *Chip8) UpdateTimers() {
	//Count down to zero
	if vm.dt > 0 {
		vm.dt--
	}
	if vm.St > 0 {
		vm.St--
	}
}
